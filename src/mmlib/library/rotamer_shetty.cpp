// PD is a free, modular C++ library for biomolecular simulation with a 
// flexible and scriptable Python interface. 
// Copyright (C) 2003-2013 Mike Tyka and Jon Rea
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "global.h"
#include "tools/vector.h"
#include "library/rotamer_shetty.h"

namespace Library
{
	RotLibConvert_Shetty::RotLibConvert_Shetty()
		: RotLibConvertBase()
	{
	}

	void RotLibConvert_Shetty::readLib( const std::string& _LibraryFileStem, RotamerLibrary& _RotLib )
	{
		std::ifstream* p_coordFile = NULL;
		std::ifstream* p_propensityFile = NULL;
		try
		{
			if( _RotLib.isFinalised() ) 
				throw ProcedureException("readLib() is not allowed, the rotamer library has been finalised, no further import can occur");

			// Mappings for things like HIS -> HIE HID HIP
			_RotLib.addIonisationAliasWorkingDefaults();

			setUseAltnames(_RotLib,false); // Flag that we would like to import using the PDB names!

			std::string coordFileName = _LibraryFileStem + ".pdb";
			p_coordFile = new std::ifstream(coordFileName.c_str(), std::ifstream::in);
			std::ifstream& coordFile = *p_coordFile;
			if( !coordFile.is_open() ) throw(IOException( "Shetty coordinate file not found: '" + coordFileName + "'!" ));

			std::string propensityFileName = _LibraryFileStem + ".dat";
			p_propensityFile = new std::ifstream(propensityFileName.c_str(), std::ifstream::in);
			std::ifstream& propensityFile = *p_propensityFile;
			if( !propensityFile.is_open() ) throw(IOException( "Shetty propensity file not found: '" + propensityFileName + "'!" ));
			
			RotamerAtom importAtom;
			std::vector<RotamerAtom> importAtoms;
			int resIndex = INT_MAX;
			StringBuilder sb;
			StringBuilder temp(4);
			StringBuilder resname(3);

			// Shetty resname mappings
			std::vector<std::string> resNames;
			std::vector<char> resSingleLetters;

			sb << coordFile;
			ASSERT( sb.size() >= 45 && sb.compare("REMARK     GENERATED BY RAPPER (VERSION 0.6.0",0,45,0,false),
				ParseException,
				"The input coordinate file does not appear to be in Shetty format");

			sb << propensityFile;
			double degreeResln = sb.parseDouble();
			ASSERT( 0.0 < degreeResln && degreeResln <= 360.0, ParseException, 
				"Imported shetty propensity bin resolution is not within the sensible range");
			double remainder =  360.0 - floor( 360.0 / degreeResln ) * degreeResln;
			ASSERT( Maths::SigFigEquality(remainder, 0.0, 8 ),
				ParseException, "Imported shetty propensity bin resolution does not yield an integer number of bins");
			int binResln = (int)(360.0 / degreeResln);

			// 1) Import atom definitions
			while( sb << coordFile )
			{
				sb.Trim();
				if( sb.size() < 54 ) 
					continue; // Effectively an empty line, cos it cant by definition contain all the info below...
				if( sb.compare("ATOM  ",0,6,0) )
				{
					temp.setTo(sb,12,4);
					temp.Trim(); // Turn "N   " into "N" for PD FFParam compatibility
					importAtom.Name = temp.toString();
					importAtom.IdealPos.setTo(
						sb.parseDouble(30,8),
						sb.parseDouble(38,8),
						sb.parseDouble(46,8)				
						);

					int currentResIndex = sb.parseInt(22,4);
					if( resIndex != currentResIndex || !sb.compare(resname,17,3,0) )
					{
						// on the first itteration of the cycle, we must add the first atom, so test for INT_MAX
						if( resIndex != INT_MAX ) 
						{							
							// HACK!!
							// The shetty lib is odd in that sometimes its Arg NH2 and NH1 atoms are swapped!
							// and also their PHE CD1:CD2 and CE1:CE2 inversions (feckers ;-))
							if( resname.compare("ARG",0,3,0) )
							{
								size_t a = FindFirstInVector(importAtoms,"NH1");
								size_t b = FindFirstInVector(importAtoms,"NH2");
								if( a != SIZE_T_FAIL && b != SIZE_T_FAIL && a > b )
								{
									importAtoms[a].Name = "NH2";
									importAtoms[b].Name = "NH1";
								}
							}
							else if( resname.compare("PHE",0,3,0) )
							{
								size_t a = FindFirstInVector(importAtoms,"CD1");
								size_t b = FindFirstInVector(importAtoms,"CD2");
								if( a != SIZE_T_FAIL && b != SIZE_T_FAIL && a > b )
								{
									importAtoms[a].Name = "CD2";
									importAtoms[b].Name = "CD1";
								}
								a = FindFirstInVector(importAtoms,"CE1");
								b = FindFirstInVector(importAtoms,"CE2");
								if( a != SIZE_T_FAIL && b != SIZE_T_FAIL && a > b )
								{
									importAtoms[a].Name = "CE2";
									importAtoms[b].Name = "CE1";
								}
							}

							// Add the new rotamer
							_RotLib.addRotamer(resname.toString(),importAtoms, ProbabilityByPhiPsiMap(binResln) );
							// Reinitialise residue
							importAtoms.clear();
						}
						importAtoms.push_back(importAtom);
						resIndex = currentResIndex;
						resname.setTo(sb,17,3);

						// Store these mappings, they are used in the corresponding dat file
						std::string r = resname.toString();
						if( !VectorContains(resNames,r) )
						{
							resNames.push_back(r);
							resSingleLetters.push_back(sb[21]);
						}
					}
					else
					{
						importAtoms.push_back(importAtom);
					}
				}
			}
			if( importAtoms.size() > 0 )
			{
				// Add the final rotamer
				_RotLib.addRotamer(resname.toString(),importAtoms, ProbabilityByPhiPsiMap(binResln));
			}

			// 2) Import propensity definitions
			char prevSeekLetter = '\0';
			RotamerSet* rotSet = NULL;
			ProbabilityByPhiPsiMap* prob;
			while(sb << propensityFile)
			{
				sb.Trim();
				if( sb.size() == 0 ) 
					continue;

				// 'R     0 -180.000 -180.000    0.004'
				if( sb[0] != prevSeekLetter )
				{
					prevSeekLetter = sb[0];
					ASSERT( sb.size() > 7 && sb[0] != '\0', ParseException, "Expected a single letter residue alias");
					size_t mapIndex = FindFirstInVector( resSingleLetters, sb[0] );
					ASSERT(mapIndex != SIZE_T_FAIL, ParseException, "Single letter mapping could not be found");
					std::string resname = resNames[mapIndex];
					resIndex = _RotLib.getIDForResidue(resname);
					ASSERT( resIndex != SIZE_T_FAIL, CodeException, "Cant find residue");
					rotSet = &_RotLib.getRotamerSet(resIndex);
				}

				int index = sb.parseInt(1,6);
				Rotamer& rot = rotSet->getRotamer(index);
				// static_cast: we **know** for sure (as we added it above) that this is a 'ProbabilityByPhiPsiMap'
				prob = static_cast<ProbabilityByPhiPsiMap*>(&rot.getProbMap());
				sb.TruncateLeftBy(7); // 'R     0'
				prob->assignFrom(sb);
			}

			// 3) Ionisation Mappings - override propensities
			const std::vector<StringPair> ionAliases = _RotLib.getIonMaps();
			for( size_t i = 0; i < ionAliases.size(); i++ )
			{
				const StringPair& s = ionAliases[i];
				size_t rotDonorIndex = _RotLib.getIDForResidue(s.p);
				size_t rotAcceptorIndex = _RotLib.getIDForResidue(s.q);
				ASSERT( rotDonorIndex != SIZE_T_FAIL && rotAcceptorIndex != SIZE_T_FAIL,
					CodeException, "Assumption failure");
				const RotamerSet& rotDonor = _RotLib.getRotamerSet(rotDonorIndex);
				RotamerSet& rotAcceptor = _RotLib.getRotamerSet(rotAcceptorIndex);

				ASSERT( rotDonor.nRot() == rotAcceptor.nRot(), CodeException, "Assumption Failure");

				for( size_t j = 0; j < rotDonor.nRot(); j++ )
				{
					// Up-cast to ProbabilityByPhiPsiMap - we **know** it has to be one (see above)
					const ProbabilityByPhiPsiMap* d = 
						static_cast<const ProbabilityByPhiPsiMap*>(&rotDonor.getRotamer(j).getProbMap());
					ProbabilityByPhiPsiMap* a = 
						static_cast<ProbabilityByPhiPsiMap*>(&rotAcceptor.getRotamer(j).getProbMap());
					a->setTo(*d);
				}
			}

			// 4) Ensure all maps have assignments. Gly and Ala will not have a BBMap!
			for ( size_t i = 0; i < _RotLib.size(); i++ )
			{
				rotSet = &_RotLib.getRotamerSet(i);
				for ( size_t j = 0; j < rotSet->nRot(); j++ )
				{
					Rotamer& rot = rotSet->getRotamer(j);
					prob = static_cast<ProbabilityByPhiPsiMap*>(&rot.getProbMap());
					if( prob->numAssignments() == 0 )
					{
						// Override with a constant probability. The number of rotamers should be 1.
						// If its not, each one is assigned an equal probability, summating to 1.0;
						rot.setProbMap( ConstantProbability( (1.0 / (double)rotSet->nRot() ) ) );
					}
				}
			}

			// Ensure file-handle cleanup
			if( p_coordFile != NULL )
			{
				p_coordFile->close();
				delete p_coordFile;
			}
			if( p_propensityFile != NULL )
			{
				p_propensityFile->close();
				delete p_propensityFile;
			}
		}
		catch( ExceptionBase ex )
		{
			// Ensure file-handle cleanup
			if( p_coordFile != NULL )
			{
				p_coordFile->close();
				delete p_coordFile;
			}
			if( p_propensityFile != NULL )
			{
				p_propensityFile->close();
				delete p_propensityFile;
			}
			throw ex;
		}
	}
}

