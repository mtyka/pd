// PD is a free, modular C++ library for biomolecular simulation with a 
// flexible and scriptable Python interface. 
// Copyright (C) 2003-2013 Mike Tyka and Jon Rea
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

#include "global.h"

#include "forcefields/ffparam.h"
#include "forcefields/ffbonded.h"
#include "workspace/workspace.h"
#include "workspace/space.h"

#include "psfdcd.h"


namespace IO
{


	int OutTra_NAMD::create()
	{
		write_DCD_header(filename_DCD.c_str());
		printPSFfile( filename_PSF.c_str() );
		created = true;
		return 0;
	}

	// PSF Members


	void OutTra_NAMD::printPSFfile( const char *filename ){

		FILE *file;
		file = fopen(filename,"w");

		printPSFfile_structure(file);

		// Make a bonded forcefield and ask it to print the bonds and angles etc..
		Physics::Forcefield ff(getWSpace());
		Physics::FF_Bonded ffbonded(getWSpace());
		ffbonded.setIgnoreForcefieldParams(true);
		ffbonded.OutputLevel = Verbosity::Normal;
		ff.add(ffbonded);
		ff.setup();
		ffbonded.printPSFfile_bondedparams(file);

		fclose(file);

	}

	int OutTra_NAMD::printPSFfile_structure(FILE *file)
	{
		int i;

		fprintf(file, "PSF\n\n%8d !NTITLE\n", 1);
		fprintf(file, " REMARKS %s\n", "generated structure PSF file (X-PLOR format)");
		fprintf(file, "\n");

		const ParticleStore  &atom = getWSpace().atom;
		size_t natom = getWSpace().atom.size();

		// print atoms
		fprintf(file, "%8d !NATOM\n", natom);

		for(i = 0; i < natom; i++) 
		{
			fprintf(file, "%8d %-4s %-4d %-4s %-4s %-4s %10.6lf %9.4lf %10d\n",
				i + 1,
				"SEG0",
				atom[i].ir,
				atom[i].parentl3name.c_str(),
				atom[i].pdbname.c_str(),
				atom[i].type_name.c_str(),
				atom[i].charge,
				atom[i].mass / Physics::PhysicsConst::amu, 0);
		}

		fprintf(file, "\n");

		return 0;
	}

	int OutTra_NAMD::printPSFfile_structurePDB(FILE *file)
	{
		int i;

		SnapShotAtom *atom = getWSpace().cur.atom;
		size_t natom = getWSpace().atom.size();

		fprintf(file, "REMARK Generated by pd ...\n");
		for(i = 0; i < natom; i++) 
		{
			fprintf(file, "%s%5d %4s%c%-4s%c%4d%c %8.3lf%8.3lf%8.3lf%6.2lf%6.2lf %-4s\n",
				"ATOM",
				i + 1,
				getWSpace().atom[i].parentl3name.c_str(),
				' ',
				getWSpace().atom[i].pdbname.c_str(),
				' ', getWSpace().atom[i].ir, ' ', atom[i].p.x, atom[i].p.y, atom[i].p.z, 1.00, 0.00, "SEG0");
		}

		fprintf(file, "END\n");

		return 0;
	}

	// DCD Members

	int OutTra_NAMD::append()
	{
		if(!created) create();
		append_DCD_step(filename_DCD.c_str());
		return 0;
	}

	int OutTra_NAMD::write_DCD_header(const char *filename)
	{
		FILE *file;

		file = fopen(filename,"wb");
		if(file==NULL)
		{
			throw(IOException(std::string("ERROR: Cannot write DCD Header to ") + std::string(filename)));
			return -1;
		}

		size_t N = getWSpace().atom.size(); //N - Number of atoms
		int NFILE = 0; //NFILE - Number of sets of coordinates
		int NPRIV = 1; //NPRIV - Starting Timestep of DCD file - NOT ZERO
		int NSAVC = 1; //NSAVC - Timesteps between DCD saves
		int NSTEP = 0; //NSTEP - Number of Timesteps
		float DELTA = (float) 1E-15; //DELTA - length of a Timestep
		bool with_unitcell = false;

		int out_integer;
		float out_float;
		char title_string[200];

		out_integer = 84;
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		strcpy(title_string, "CORD");
		fwrite(title_string, 4, 1, file);
		out_integer = NFILE; /* located at fpos 8 */
		out_integer = 0; /* ignore the lies */
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		out_integer = NPRIV; /* located at fpos 12 */
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		out_integer = NSAVC; /* located at fpos 16 */
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		out_integer = NSTEP; /* located at fpos 20 */
		out_integer = NPRIV - NSAVC; /* ignore the lies */
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		out_integer=0;
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		out_float = (float)DELTA;
		fwrite((void *) &out_float, sizeof(float), 1, file);
		out_integer = 0; //with_unitcell ? 1 : 0;
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		out_integer = 0;
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		out_integer = 24; 
		fwrite((void *) &out_integer, sizeof(int), 1, file);
		out_integer = 84;

		fwrite((void *) & out_integer, sizeof(int), 1, file);

		out_integer = 164;
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		out_integer = 2;
		fwrite((void *) & out_integer, sizeof(int), 1, file);

		sprintf(title_string, "REMARKS DCD CREATED BYpd ");
		fwrite((void*)title_string, 80, 1, file);
		fwrite((void*)title_string, 80, 1, file);

		out_integer = 164;
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		out_integer = 4;
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		out_integer = (int)N;
		fwrite((void *) & out_integer, sizeof(int), 1, file);
		out_integer = 4;
		fwrite((void *) & out_integer, sizeof(int), 1, file);


		fclose(file);
		return 0;
	}

	int OutTra_NAMD::append_DCD_step(const char *filename)
	{
		FILE *file;

		file = fopen(filename,"ab");
		if(file==NULL)
		{
			throw(IOException(std::string("ERROR: Cannot write DCD Step to ") + std::string(filename)));
		}

		//int NSAVC,NSTEP,NFILE;
		int NFILE_POS = 8;
		int NPRIV_POS = 12;
		int NSAVC_POS = 16;
		int NSTEP_POS = 20;
		int out_integer;

		// Unit cell - currently not supported
		// out_integer = 48;
		// fwrite((void *) &out_integer, sizeof(int), 1, file);
		// fwrite((void *) cell, out_integer);
		// fwrite((void *) &out_integer, sizeof(int), 1, file);
		//}

		int N = (int)getWSpace().atom.size();
		int i;
		out_integer = N*4;

		fwrite((void *) &out_integer, sizeof(int), 1, file);
		for(i=0;i<getWSpace().atom.size();i++)
		{
			float x = (float)getWSpace().cur.atom[i].p.x; 
			fwrite((void *) &x, sizeof(float), 1, file);
		}
		fwrite((void *) &out_integer, sizeof(int), 1, file);

		fwrite((void *) &out_integer, sizeof(int), 1, file);
		for(i=0;i<getWSpace().atom.size();i++)
		{
			float y = (float)getWSpace().cur.atom[i].p.y;
			fwrite((void *) &y, sizeof(float), 1, file);
		}
		fwrite((void *) &out_integer, sizeof(int), 1, file);

		fwrite((void *) &out_integer, sizeof(int), 1, file);
		for(i=0;i<getWSpace().atom.size();i++)
		{
			float z = (float)getWSpace().cur.atom[i].p.z;
			fwrite((void *) &z, sizeof(float), 1, file);
		}
		fwrite((void *) &out_integer, sizeof(int), 1, file);


		fclose(file);
		return 0;

		// NOTE: Although the rest of the code is supposed to be here it somehow
		// breaks the dcd file for an unknown reason. However if you leave it out
		// it appears to work - so i'm just going to leave it as is for now.
		/*

		//	file = fopen(filename,"wb");

		// update header
		fseek(file,NSAVC_POS,SEEK_SET);
		fread((void*) &NSAVC,sizeof(int), 1, file);
		fseek(file,NSTEP_POS,SEEK_SET);
		fread((void*) &NSTEP,sizeof(int), 1, file);
		fseek(file,NFILE_POS,SEEK_SET);
		fread((void*) &NFILE,sizeof(int), 1, file);
		NSTEP += NSAVC;
		NFILE += 1;
		fseek(file,NSTEP_POS,SEEK_SET);
		fwrite((void *) &NSTEP,sizeof(int), 1, file);
		fseek(file,NFILE_POS,SEEK_SET);
		fwrite((void *) &NFILE,sizeof(int), 1, file);
		fseek(file,0,SEEK_END);

		fclose(file);
		return 0;

		*/
	}




	void OutputFile_PSF::save( WorkSpace &_wspace){
		OutTra_NAMD outtra( filestem, _wspace );
		outtra.printPSFfile( outtra.filename_PSF.c_str() );
	}


	void OutputFile_DCD::save( WorkSpace &_wspace){
		OutTra_NAMD outtra( filestem, _wspace );
		outtra.write_DCD_header( outtra.filename_DCD.c_str() );
		outtra.append_DCD_step( outtra.filename_PSF.c_str() );
	}


} //namespace IO

